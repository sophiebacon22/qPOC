import github
import boto3
from botocore.exceptions import ClientError
import os
from dotenv import load_dotenv

load_dotenv()  # Load environment variables from .env file

# Initialize GitHub client
g = github.Github(os.getenv('GITHUB_TOKEN'))

# Initialize Bedrock client
bedrock = boto3.client(
    service_name='bedrock-runtime',
    region_name='us-east-1',
    aws_access_key_id=os.getenv('AWS_ACCESS_KEY_ID'),
    aws_secret_access_key=os.getenv('AWS_SECRET_ACCESS_KEY')
)

def create_master_context(repo_url):
    # Extract owner and repo name from URL
    _, _, _, owner, repo_name = repo_url.rstrip('/').split('/')
    
    repo = g.get_repo(f"{owner}/{repo_name}")
    contents = repo.get_contents("")
    file_contents = []

    while contents:
        file_content = contents.pop(0)
        if file_content.type == "dir":
            contents.extend(repo.get_contents(file_content.path))
        else:
            file_contents.append(f"File: {file_content.path}\n{file_content.decoded_content.decode()}\n\n")

    all_content = "\n".join(file_contents)

    # Use Bedrock to generate master context
    try:
        response = bedrock.invoke_model(
            modelId='anthropic.claude-v2',  # or appropriate model ID
            body=json.dumps({
                "prompt": f"Given the following repository contents, create a master context summarizing the project structure and key components:\n\n{all_content}",
                "max_tokens_to_sample": 2000
            })
        )
        master_context = json.loads(response['body'].read())['completion']
        return master_context
    except ClientError as e:
        raise Exception(f"Error calling Bedrock: {str(e)}")

def generate_code(task_description, master_context):
    try:
        response = bedrock.invoke_model(
            modelId='anthropic.claude-v2',  # or appropriate model ID
            body=json.dumps({
                "prompt": f"Given the following master context:\n{master_context}\n\nAnd the task description:\n{task_description}\n\nGenerate the necessary code changes:",
                "max_tokens_to_sample": 2000
            })
        )
        generated_code = json.loads(response['body'].read())['completion']
        return generated_code
    except ClientError as e:
        raise Exception(f"Error calling Bedrock: {str(e)}")

def apply_post_processing(generated_code):
    # This is a placeholder. In a real implementation, you'd use a coding standards tool or another AI call.
    return generated_code  # For now, just return the code as-is

def commit_and_push_changes(repo_url, changes):
    _, _, _, owner, repo_name = repo_url.rstrip('/').split('/')
    
    repo = g.get_repo(f"{owner}/{repo_name}")
    
    # Create a new branch
    base_branch = repo.default_branch
    new_branch = f"feature-{int(time.time())}"
    ref = repo.create_git_ref(f"refs/heads/{new_branch}", repo.get_branch(base_branch).commit.sha)

    # Commit changes
    repo.create_file(
        path="generated_changes.py",
        message="AI-generated changes",
        content=changes,
        branch=new_branch
    )

    # Create a pull request
    pr = repo.create_pull(
        title="AI-generated changes",
        body="These changes were generated by the Amazon Q Developer Demo",
        head=new_branch,
        base=base_branch
    )

    return pr.html_url
